<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Murder House</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050506;
      color: #f7e4da;
    }
    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 32px 16px 40px;
    }
    .highlight-yellow {
      color: #ffe680 !important;
      font-weight: 600;
    }

    /* --- TOP HEADER LAYOUT (title + round + identity mini card) --- */
    .top-layout {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .title-block {
      flex: 0 0 auto;
      text-align: center;
    }
    h1 {
      letter-spacing: 0.16em;
      font-size: 32px;
      color: #ff3b3b;
      margin: 0 0 6px;
    }
    .subtitle {
      font-size: 13px;
      color: #e3c9bd;
      margin-bottom: 4px;
    }
    .round-wrap {
      margin-top: 4px;
    }
    .round-pill {
      display: inline-block;
      padding: 8px 32px;
      border-radius: 999px;
      border: 1px solid #ff3b3b;
      color: #ffb5b5;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
    }

    /* mini identity card beside title */
    .header-identity {
       max-width: 280px;
      margin-top: 4px;
      padding: 14px 14px 12px;
    }
    .header-identity h2 {
      font-size: 14px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      margin: 0 0 4px;
    }
    .header-identity small {
      font-size: 10px;
      margin-bottom: 8px;
    }
    .header-identity .muted {
      font-size: 10px;
      line-height: 1.4;
    }
    .header-identity button {
      margin-top: 10px;
      width: 100%;
      font-size: 11px;
      padding: 7px 10px;
    }

    @media (max-width: 820px) {
      .top-layout {
        flex-direction: column;
        align-items: stretch;
      }
      .title-block {
        text-align: center;
      }
      .header-identity {
        width: 100%;
      }
    }

    .grid {
      display: grid;
      grid-template-columns: 1.2fr 1.2fr;
      grid-gap: 18px;
    }
    .card {
      background: radial-gradient(circle at top, #1c0c10 0, #090305 55%, #050506 100%);
      border-radius: 16px;
      border: 1px solid #3b1518;
      padding: 12px 12px 14px;
      box-shadow: 0 0 18px rgba(0,0,0,0.8);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: #ffded6;
    }
    .card small {
      display: block;
      font-size: 11px;
      color: #c5a59a;
      margin-bottom: 10px;
    }

    .souls-card {
      padding-top: 12px;
      padding-bottom: 14px;
    }

    label {
      display: block;
      font-size: 12px;
      margin-bottom: 4px;
      color: #e6c0b5;
    }
    input, select {
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #4b252a;
      background: #120608;
      color: #f7e4da;
      font-size: 13px;
      outline: none;
    }
    input:focus, select:focus {
      border-color: #ff3b3b;
      box-shadow: 0 0 0 1px rgba(255,59,59,0.35);
    }
    button {
      margin-top: 8px;
      padding: 9px 14px;
      border-radius: 999px;
      border: 1px solid #ff3b3b;
      background: linear-gradient(90deg, #871818, #571011);
      color: #ffe7df;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      cursor: pointer;
    }
    button:hover {
      filter: brightness(1.1);
    }
    button:active {
      transform: translateY(1px);
    }
    button:disabled {
      opacity: .6;
      cursor: default;
    }
    .status {
      margin-top: 10px;
      padding: 7px 9px;
      border-radius: 8px;
      font-size: 12px;
      background: #140607;
      border: 1px solid #3d1518;
      color: #f1d0c4;
      min-height: 22px;
    }
    .status.error {
      border-color: #ff5252;
      color: #ffbbbb;
    }
    .status.success {
      border-color: #3bc772;
      color: #c3ffd8;
    }
    .muted {
      font-size: 11px;
      color: #a98a7f;
    }
    .hidden {
      display: none;
    }
        #killer-move-banner {
      margin-top: 6px;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
    }

    /* Waiting state – bright yellow */
    #killer-move-banner.waiting {
      background: #ffd60a;
      color: #000;
    }

    /* Ready state – green */
    #killer-move-banner.ready {
      background: #2ecc71;
      color: #fff;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 8px;
    }
    th, td {
      border-bottom: 1px solid #3b1518;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      color: #ffded6;
      font-weight: 600;
    }
    .section-title {
      font-size: 14px;
      margin: 4px 0 2px;
      color: #ffd5ca;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    ul {
      margin: 2px 0 0 18px;
      padding: 0;
      font-size: 12px;
    }
    li {
      margin: 2px 0;
    }

    /* Souls / Bodies names red */
    #room-players-list li,
    #room-bodies-list li {
      color: #ff4c4c;
    }

    @media (max-width: 820px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    /* --- PLAYER LAYOUT: left = room + map, right = lists + actions --- */
    #player-view .player-grid {
      display: grid;
      grid-template-columns: minmax(0, 520px) minmax(0, 1fr);
      grid-gap: 12px;
      align-items: start;
    }

    #player-view .right-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    @media (max-width: 820px) {
      #player-view .player-grid {
        grid-template-columns: 1fr;
      }
      #player-view .right-column {
        gap: 8px;
      }
    }

    /* --- PLAYER parchment mini-map --- */
    .player-map {
      position: relative;
      width: 100%;
      max-width: 420px;
      margin-top: 8px;
      aspect-ratio: 665 / 900;
      background-image: url('mh-map-player.png');
      background-position: center;
      background-size: contain;
      background-repeat: no-repeat;
      background-color: #050506;
      overflow: visible;
    }
    /* Keep room description no wider than the mini map */
    #room-description {
      max-width: 420px;
    }

    /* Brighter candlelight glow */
    .player-map .candle-glow {
      position: absolute;
      top: -1%;
      right: 6%;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      pointer-events: none;
      background: radial-gradient(circle,
        rgba(255, 240, 200, 1.0) 0%,
        rgba(255, 210, 130, 0.85) 30%,
        rgba(255, 170, 80, 0.4) 55%,
        rgba(0, 0, 0, 0) 82%
      );
      opacity: 0.95;
      filter: blur(1.2px);
      mix-blend-mode: screen;
      animation: candle-flicker 1.7s infinite alternate;
      z-index: 5;
    }
/* === Android & small-screen glow fix === */
@media (max-width: 768px) {
  .player-map .candle-glow {
    position: absolute;

    /* adjust glow location */
    top: -4.1%;        /* move slightly UP */
    right: 1%;        /* move LEFT to align with candle */

    /* adjust glow size */
    width: 120px;
    height: 120px;

    border-radius: 50%;
    pointer-events: none;

    /* softer, dimmer glow */
    background: radial-gradient(
      circle,
      rgba(255, 240, 200, 0.55) 0%,
      rgba(255, 210, 130, 0.30) 33%,
      rgba(255, 160, 80, 0.15) 57%,
      rgba(0, 0, 0, 0) 83%
    );

    opacity: 0.95;
    filter: blur(1px);
    mix-blend-mode: screen;

    animation: candle-flicker 1.5s infinite alternate;
    z-index: 5;
  }
}


    @keyframes candle-flicker {
      0% {
        opacity: 0.7;
        transform: translate(-1px, 1px) scale(0.97);
      }
      50% {
        opacity: 1;
        transform: translate(0px, 0px) scale(1.05);
      }
      100% {
        opacity: 0.8;
        transform: translate(1px, -1px) scale(0.99);
      }
    }

    .player-map .room-dot-area {
      position: absolute;
      width: 22%;
      height: 10%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .player-map .room-dot-area.current-room {
      outline: 1px solid rgba(255, 179, 71, 0.9);
      box-shadow: 0 0 8px rgba(255, 179, 71, 0.7);
      border-radius: 12px;
    }

    .player-map .dots {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 4px;
    }

    .map-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: #ff3030;
      box-shadow:
        0 0 6px rgba(255, 100, 100, 1),
        0 0 14px rgba(255, 40, 40, 0.95),
        0 0 22px rgba(255, 0, 0, 0.85);
    }

    .map-dot.dead {
      background: #666666;
      box-shadow: 0 0 4px rgba(80, 80, 80, 0.8);
    }

    /* --- GM map grid --- */
    .map-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 8px;
    }

    .map-grid .map-room {
      position: relative;
      border: 1px solid #3b1518;
      border-radius: 10px;
      padding: 4px 6px 18px;
      font-size: 10px;
      line-height: 1.3;
      background: #0b0507;
    }

    .map-grid .map-room .room-name {
      display: block;
      margin-bottom: 2px;
      color: #f6d4c8;
    }

    .map-grid .map-room .dots {
      position: absolute;
      left: 6px;
      bottom: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
    }

    .status-good {
      color: #9bff9b;
      font-weight: 600;
    }

    .status-bad {
      color: #ff9b9b;
      font-weight: 600;
    }

    #kill-section {
      display: none;
    }

    #gm-most-voted {
      margin-top: 6px;
      color: #ffd966;
      font-weight: 600;
    }

    /* Clue collected (GM table) */
    .clue-collected {
      color: #9bff9b;
      font-weight: 600;
    }

    /* --- DEAD banner --- */
    .dead-banner {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #ff3b3b;
      background: linear-gradient(135deg,#3b0505,#1a0000 40%,#2b0000);
      color: #ffd9d9;
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      box-shadow: 0 0 14px rgba(0,0,0,0.8);
    }
    .dead-banner strong {
      color: #ff7777;
    }
    .dead-banner::before {
      content: "";
      position: absolute;
      top: -12px;
      left: 6%;
      width: 88%;
      height: 26px;
      background:
        radial-gradient(circle at 10% 120%, #5a0000 0, transparent 55%),
        radial-gradient(circle at 40% 120%, #7b0000 0, transparent 55%),
        radial-gradient(circle at 75% 120%, #5a0000 0, transparent 55%);
      opacity: 0.95;
      filter: blur(0.4px);
    }
    .dead-banner::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle, rgba(255, 0, 0, 0.18) 0%, rgba(0, 0, 0, 0) 60%);
      mix-blend-mode: screen;
      opacity: 0;
      animation: dead-pulse 2.4s infinite;
    }
    @keyframes dead-pulse {
      0% { opacity: 0; }
      40% { opacity: 0.45; }
      100% { opacity: 0; }
    }

    /* Global popup overlay for: death, Room Reveal, Shove, Killer’s Gaze, Screams */
    .global-popup-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.94);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .global-popup-overlay.hidden {
      display: none;
    }
    .global-popup-card {
      background: radial-gradient(circle at top, #3f0202 0, #1a0000 50%, #050101 100%);
      border-radius: 18px;
      border: 2px solid #ff3b3b;
      padding: 26px 22px 20px;
      max-width: 420px;
      text-align: center;
      box-shadow:
        0 0 18px rgba(0,0,0,0.9),
        0 0 32px rgba(255,0,0,0.45);
    }
    .global-popup-title {
      font-size: 20px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: #ff8585;
      margin-bottom: 10px;
    }
    .global-popup-body {
      font-size: 14px;
      color: #ffd6d6;
      margin-bottom: 18px;
    }
    .global-popup-close {
      display: inline-block;
      margin-top: 4px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid #ff3b3b;
      background: linear-gradient(90deg, #b31212, #6f0505);
      color: #ffe7df;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      cursor: pointer;
    }

    @media (max-width: 600px) {
      .card {
        padding: 12px 12px 14px;
      }
      .section-title {
        margin: 4px 0 2px;
      }
      ul {
        margin-left: 14px;
      }
    }
  </style>
</head>
<body>
  <!-- shared overlay popup -->
  <div id="global-popup-overlay" class="global-popup-overlay hidden">
    <div class="global-popup-card">
      <div id="global-popup-title" class="global-popup-title">Title</div>
      <div id="global-popup-body" class="global-popup-body">Body</div>
      <button id="global-popup-close" class="global-popup-close">X</button>
    </div>
  </div>

  <div class="page">
    <div class="top-layout">
      <div class="title-block">
        <h1>MURDER HOUSE</h1>
        <div class="subtitle">Secret roles. Silent movement. Loud accusations.</div>
        <div class="round-wrap">
          <div id="round-pill" class="round-pill">ROUND —</div>
        </div>
      </div>

      <!-- Identity mini card beside title (hidden unless in player view) -->
      <div id="header-identity-card" class="card header-identity hidden">
        <h2>Your Identity</h2>
        <small>Keep this hidden from everyone else.</small>

        <div class="muted">
          Name: <span id="player-name-label" class="highlight-yellow">—</span><br/>
          Role: <span id="player-role-label" class="highlight-yellow">—</span><br/>
          PIN: <span id="player-pin-label" class="highlight-yellow">—</span>
        </div>

        <!-- DEAD banner: shows only if THIS player is dead -->
        <div id="dead-banner" class="dead-banner hidden">
          <strong>You were murdered.</strong> You are now part of the floor. You cannot SPEAK, GESTURE or HINT.
        </div>

        <button id="leave-game-btn">Leave Game / Join New Run</button>
      </div>
    </div>

    <!-- LOBBY -->
    <div id="lobby-view" class="grid">
      <div class="card">
        <h2>Player Entrance</h2>
        <small>Enter your name to join this run. The GM will give you your PIN and role.</small>

        <label for="name-input">Your name</label>
        <input id="name-input" placeholder="e.g., Theo Chau" />
        <button id="join-btn">Join Game</button>

        <div class="section-title">Rejoin with PIN</div>
        <label for="rejoin-pin">You already have a PIN</label>
        <input id="rejoin-pin" placeholder="e.g., 42" />
        <button id="rejoin-btn">Rejoin</button>

        <div id="lobby-status" class="status"></div>
      </div>

      <div class="card">
        <h2>GM Control (Locked)</h2>
        <small>GM only. Players should not see this PIN.</small>

        <label for="gm-pin">GM PIN</label>
        <input id="gm-pin" type="text" inputmode="numeric" maxlength="4" autocomplete="off" placeholder="Enter GM PIN" />
        <button id="gm-unlock-btn">Unlock GM Panel</button>

        <div class="muted" style="margin-top:6px;">
          Tip: GM should use their own device. Once you join as a player on this device, GM controls will hide.
        </div>

        <div id="gm-unlock-status" class="status"></div>
      </div>
    </div>

    <!-- PLAYER VIEW -->
    <div id="player-view" class="hidden">
      <div class="player-grid">
        <!-- LEFT: Your room info + map -->
        <div class="card">
          <div class="section-title">Your Room</div>
          <div class="muted">
            Room: <span id="player-room-label" class="highlight-yellow">—</span>
          </div>
          <p id="room-description" style="font-size:13px;margin-top:6px;"></p>

          <div id="player-mini-map" class="player-map">
            <!-- candle glow overlay -->
            <div class="candle-glow"></div>

            <!-- positions tuned to match background image -->
            <div class="room-dot-area" data-room="FORGOTTEN CELLAR" style="top: 32.5%; left: 36%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="THE UNDERHOUSE" style="top: 48%; left: 42%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="THE IRON CHAMBER" style="top: 43%; left: 72.5%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="WHISPERING HALL" style="top: 68%; left: 49%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="THE FLICKERING LAMP STUDY" style="top: 62%; left: 22%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="THE SILENT BEDROOM" style="top: 76%; left: 23%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="THE BLOOD-STAINED KITCHEN" style="top: 61%; left: 74.5%;">
              <div class="dots"></div>
            </div>
            <div class="room-dot-area" data-room="PARLOR OF ECHOES" style="top: 75%; left: 76%;">
              <div class="dots"></div>
            </div>
          </div>
        </div>

        <!-- RIGHT: Souls/Bodies/Clues (top) + Actions (bottom) -->
        <div class="right-column">
          <div class="card souls-card">
            <div class="section-title">Souls In This Room</div>
            <ul id="room-players-list"></ul>

            <div class="section-title">Bodies On The Floor</div>
            <ul id="room-bodies-list"></ul>

            <div class="section-title">Room Clues</div>
            <ul id="player-room-clues-list"></ul>

            <div class="section-title">Your Collected Clues</div>
            <ul id="player-collected-clues-list"></ul>
          </div>

          <div id="actions-card" class="card">
  <h2>Actions</h2>
  <small>Moves are secret. Kills are quieter.</small>

  <!-- MOVE SECTION -->
  <div id="move-section">
    <div class="section-title">Move</div>
    <label for="move-room-select">Choose adjacent room</label>
    <select id="move-room-select">
      <option value="">-- choose room --</option>
    </select>
    <button id="move-btn">Record Move</button>
    <div id="killer-move-banner" class="muted hidden"></div>
  </div>

  <!-- KILL SECTION (killer only, JS already hides/shows this) -->
  <div id="kill-section">
    <div class="section-title">Kill (Killer only)</div>
    <small class="muted">
      You may only strike if exactly one other living player shares this room, and all living players have moved this round.
    </small>
    <label for="kill-target-select" style="margin-top:6px;">Eligible victim in this room</label>
    <select id="kill-target-select">
      <option value="">-- no valid victim --</option>
    </select>
    <button id="kill-btn">Attempt Kill</button>
  </div>

  <!-- VOTE SECTION -->
  <div id="vote-section">
    <div class="section-title">Vote</div>
    <label for="vote-select">Accuse a player</label>
    <select id="vote-select">
      <option value="">-- choose someone --</option>
    </select>
    <button id="vote-btn">Record Vote</button>
  </div>

  <!-- Ghost event voting (dead players only – JS toggles this separately) -->
  <div id="ghost-event-block" class="hidden" style="margin-top:10px;">
    <div class="section-title">Ghost Event Vote</div>
    <small class="muted">
      As a ghost, you may vote for a curse. The house triggers a ghost-chosen event every few rounds.
    </small>
    <label for="ghost-event-select" style="margin-top:6px;">Choose an event</label>
    <select id="ghost-event-select">
      <option value="">-- choose an event --</option>
      <option value="shove">The Shove in the Dark</option>
      <option value="scream">Screams</option>
      <option value="reveal">Room Reveal</option>
      <option value="gaze">Killer’s Gaze</option>
    </select>
    <button id="ghost-vote-btn">Cast Ghost Vote</button>
  </div>

  <div id="player-status" class="status"></div>
</div>

        </div>
      </div>
    </div>

    <!-- GM VIEW -->
    <div id="gm-view" class="hidden">
      <div class="grid">
        <div class="card">
          <h2>GM Control</h2>
          <small>Only the GM should ever see this.</small>

          <div class="muted">
            Round: <span id="gm-round-label">1</span>
          </div>

          <button id="gm-next-round-btn">Next Round</button>
          <button id="gm-new-game-btn" style="margin-left:6px;">New Game</button>

          <div class="section-title">Secret Sentence &amp; Clues</div>
          <label for="gm-secret-sentence">Secret sentence (6–8 words)</label>
          <input id="gm-secret-sentence" placeholder="e.g., THE KILLER HIDES IN THE CELLAR" />
          <button id="gm-generate-clues-btn">Scatter Clues</button>
          <div id="gm-clues-status" class="status"></div>

          <div class="section-title">Roster</div>
          <small class="muted">
            Role / Alive can be edited, then click "Save" on that row. You can also remove players.
          </small>
          <table id="gm-roster-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Name</th>
                <th>PIN</th>
                <th>Role</th>
                <th>Alive</th>
                <th>Save</th>
                <th>Remove</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>

          <!-- Randomize + Scatter moved under roster -->
          <div style="margin-top:6px;">
            <button id="gm-randomize-btn">Randomize Roles</button>
            <button id="gm-scatter-now-btn" style="margin-left:6px;">Scatter Players Now</button>
          </div>

          <!-- Manual countdown timer under roster -->
          <div class="section-title" style="margin-top:10px;">Round Timer</div>
          <small class="muted">Set the countdown in seconds (default 120) then start.</small>
          <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
            <input id="gm-timer-input" type="number" min="5" step="5" value="120" style="max-width:90px;">
            <div id="gm-timer-display" class="muted">02:00</div>
          </div>
          <div style="margin-top:4px;">
            <button id="gm-timer-start-btn">Start Timer</button>
            <button id="gm-timer-stop-btn" style="margin-left:6px;">Stop</button>
            <button id="gm-timer-reset-btn" style="margin-left:6px;">Reset</button>
          </div>

          <!-- Killer's Advantage controls -->
          <div class="section-title" style="margin-top:10px;">Killer’s Advantage</div>
          <small class="muted">
            When enabled, every N rounds the Killer may move twice and kill once
            (MOVE, MOVE, KILL or MOVE, KILL, MOVE).
          </small>
          <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
            <label for="gm-killers-adv-interval" class="muted" style="flex:0 0 auto;">Every</label>
            <input id="gm-killers-adv-interval" type="number" min="1" step="1" value="3" style="max-width:70px;">
            <span class="muted">rounds</span>
          </div>
          <button id="gm-killers-adv-toggle-btn" style="margin-top:4px;">Toggle Killer’s Advantage</button>

          <!-- Ghost event frequency -->
          <div class="section-title" style="margin-top:10px;">Ghost Event Frequency</div>
          <small class="muted">
            Dead players vote each round. The house triggers their chosen event every N rounds.
          </small>
          <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
            <input id="gm-ghost-interval-input" type="number" min="1" step="1" value="5" style="max-width:90px;">
            <button id="gm-ghost-interval-btn">Set Ghost Interval</button>
          </div>

          <!-- Round effects (all apply at start of NEXT round) -->
          <div class="section-title" style="margin-top:10px;">Round Effects (Next Round)</div>
          <button id="gm-reveal-dots-btn">Room Reveal</button>
          <button id="gm-shove-btn" style="margin-left:6px;">The Shove in the Dark</button>
          <button id="gm-killer-gaze-btn" style="margin-top:6px;">Killer's Gaze</button>
          <button id="gm-scream-btn" style="margin-left:6px;margin-top:6px;">Screams</button>
          <button id="gm-killer-clues-btn" style="margin-top:6px;">
            Toggle Killer Room Clues
          </button>

          <div id="gm-status" class="status"></div>
        </div>

        <div class="card">
          <h2>House Overview</h2>
          <small>Rooms, moves, votes, and live dots for the current round.</small>

          <div class="section-title">Rooms &amp; Names (Alive / Dead)</div>
          <table id="gm-room-names-table">
            <thead>
              <tr>
                <th>Room</th>
                <th>Players</th>
                <th>Clues</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>

          <div class="section-title">Moves This Round</div>
          <table id="gm-moves-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Moved?</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>

          <div class="section-title">Votes This Round</div>
          <table id="gm-votes-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Voted?</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>

          <div id="gm-most-voted">Most Voted For: —</div>

          <div class="section-title">Kill Attempts (Private for GM)</div>
          <div id="gm-kill-attempts" class="muted"></div>

          <!-- Ghost vote tracking -->
          <div class="section-title" style="margin-top:10px;">Ghost Event Votes (Dead Players)</div>
          <table id="gm-ghost-votes-table">
            <thead>
              <tr>
                <th>Name</th>
                <th>Voted?</th>
                <th>Choice</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div id="gm-ghost-majority" class="muted" style="margin-top:4px;">
            Ghost Majority Vote: —
          </div>

          <div id="gm-map-wrapper" style="margin-top:10px;">
            <div class="section-title">Live Map (GM Only)</div>
            <div id="gm-map" class="map-grid">
              <div class="map-room" data-room="WHISPERING HALL">
                <span class="room-name">Whispering Hall</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="THE FLICKERING LAMP STUDY">
                <span class="room-name">Lamp Study</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="THE SILENT BEDROOM">
                <span class="room-name">Silent Bedroom</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="PARLOR OF ECHOES">
                <span class="room-name">Parlor</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="THE BLOOD-STAINED KITCHEN">
                <span class="room-name">Kitchen</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="THE UNDERHOUSE">
                <span class="room-name">Underhouse</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="FORGOTTEN CELLAR">
                <span class="room-name">Cellar</span>
                <div class="dots"></div>
              </div>
              <div class="map-room" data-room="THE IRON CHAMBER">
                <span class="room-name">Iron Chamber</span>
                <div class="dots"></div>
              </div>
            </div>
          </div>

          <div class="muted" style="margin-top:10px;">
            Use this with the printed map: each room shows how many souls are hiding there, but not who.
            The dots map is just for you, GM, to keep track.
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    const state = {
      pin: null,
      gmPin: null,
      player: null,
      round: null,
      roomInfo: null,
      gmPlayers: [],
      revealDots: false
    };

    let playerPollTimer = null;
    let gmPollTimer = null;

    // per-effect popup tracking (per round)
    const popupRounds = {
      death: null,
      roomReveal: null,
      shove: null,
      killerGaze: null,
      scream: null
    };

    // GM timer
    let gmTimerInterval = null;
    let gmTimerRemaining = 120;

    function setRoundLabel(round) {
      state.round = round;
      const pill = document.getElementById('round-pill');
      pill.textContent = round ? `ROUND ${round}` : 'ROUND —';

      const gmRound = document.getElementById('gm-round-label');
      if (gmRound) gmRound.textContent = round || '—';
    }

    function show(view) {
      document.getElementById('lobby-view').classList.add('hidden');
      document.getElementById('player-view').classList.add('hidden');
      document.getElementById('gm-view').classList.add('hidden');

      const headerIdentity = document.getElementById('header-identity-card');
      if (headerIdentity) headerIdentity.classList.add('hidden');

      if (view === 'lobby') {
        document.getElementById('lobby-view').classList.remove('hidden');
      }
      if (view === 'player') {
        document.getElementById('player-view').classList.remove('hidden');
        if (headerIdentity) headerIdentity.classList.remove('hidden');
      }
      if (view === 'gm') {
        document.getElementById('gm-view').classList.remove('hidden');
      }
    }

    function setStatus(id, msg, isError) {
      const el = document.getElementById(id);
      el.textContent = msg || '';
      el.classList.remove('error', 'success');
      if (!msg) return;
      el.classList.add(isError ? 'error' : 'success');
    }

    function savePlayerToStorage(pin) {
      localStorage.setItem('mh_pin', pin);
    }

    function clearPlayerStorage() {
      localStorage.removeItem('mh_pin');
    }

    function loadPlayerFromStorage() {
      return localStorage.getItem('mh_pin') || null;
    }

    /* -------- Popup helpers -------- */

    function showGlobalPopup(title, body) {
      const overlay = document.getElementById('global-popup-overlay');
      const titleEl = document.getElementById('global-popup-title');
      const bodyEl = document.getElementById('global-popup-body');
      if (!overlay || !titleEl || !bodyEl) return;

      titleEl.textContent = title || '';
      bodyEl.textContent = body || '';
      overlay.classList.remove('hidden');
    }

    function hideGlobalPopup() {
      const overlay = document.getElementById('global-popup-overlay');
      if (!overlay) return;
      overlay.classList.add('hidden');
    }

    document.getElementById('global-popup-close').addEventListener('click', () => {
      hideGlobalPopup();
    });

    /* -------- Player helpers -------- */

    function updatePlayerMiniMap(roomInfo, revealDots, roomDots) {
      const currentRoom = roomInfo.room;
      const areas = document.querySelectorAll('#player-mini-map .room-dot-area');

      areas.forEach(div => {
        const dots = div.querySelector('.dots');
        dots.innerHTML = '';
        div.classList.toggle('current-room', div.dataset.room === currentRoom);
      });

      if (revealDots && Array.isArray(roomDots)) {
        roomDots.forEach(r => {
          const div = document.querySelector(`#player-mini-map .room-dot-area[data-room="${r.room}"]`);
          if (!div) return;
          const dots = div.querySelector('.dots');
          for (let i = 0; i < r.total; i++) {
            const dot = document.createElement('span');
            dot.className = 'map-dot';
            dots.appendChild(dot);
          }
        });
      } else {
        const here = document.querySelector(`#player-mini-map .room-dot-area[data-room="${currentRoom}"]`);
        if (!here) return;
        const dots = here.querySelector('.dots');

        (roomInfo.living || []).forEach(() => {
          const dot = document.createElement('span');
          dot.className = 'map-dot';
          dots.appendChild(dot);
        });
        (roomInfo.bodies || []).forEach(() => {
          const dot = document.createElement('span');
          dot.className = 'map-dot dead';
          dots.appendChild(dot);
        });
      }
    }

    function populateRoomState(roomInfo, revealDots, roomDots, roomClues, playerClues) {
      const roomState = roomInfo || {};
      state.roomInfo = roomState;

      document.getElementById('player-room-label').textContent = roomState.room || '—';
      document.getElementById('room-description').textContent = roomState.description || '';

      const pList = document.getElementById('room-players-list');
      const bList = document.getElementById('room-bodies-list');
      pList.innerHTML = '';
      bList.innerHTML = '';

      const living = roomState.living || [];
      const bodies = roomState.bodies || [];

      if (living.length) {
        living.forEach(p => {
          const li = document.createElement('li');
          li.textContent = p.name;
          pList.appendChild(li);
        });
      } else {
        const li = document.createElement('li');
        li.textContent = 'No living souls are here.';
        pList.appendChild(li);
      }

      if (bodies.length) {
        bodies.forEach(p => {
          const li = document.createElement('li');
          li.textContent = p.name;
          bList.appendChild(li);
        });
      } else {
        const li = document.createElement('li');
        li.textContent = 'No bodies… yet.';
        bList.appendChild(li);
      }

      // Room clues display
      const roomClueList = document.getElementById('player-room-clues-list');
      if (roomClueList) {
        roomClueList.innerHTML = '';
        if (Array.isArray(roomClues) && roomClues.length) {
          roomClues.forEach(text => {
            const li = document.createElement('li');
            li.textContent = `"${text}"`;
            roomClueList.appendChild(li);
          });
        } else {
          const li = document.createElement('li');
          li.textContent = 'No clues are visible to you in this room.';
          roomClueList.appendChild(li);
        }
      }

      // Collected clues display
      const collectedList = document.getElementById('player-collected-clues-list');
      if (collectedList) {
        collectedList.innerHTML = '';
        if (Array.isArray(playerClues) && playerClues.length) {
          playerClues.forEach(c => {
            const li = document.createElement('li');
            li.textContent = `[${c.room}] "${c.text}"`;
            collectedList.appendChild(li);
          });
        } else {
          const li = document.createElement('li');
          li.textContent = 'You have not collected any clues yet.';
          collectedList.appendChild(li);
        }
      }

      updatePlayerMiniMap(roomState, revealDots, roomDots);
    }

    function populateAllowedRooms(rooms) {
      const sel = document.getElementById('move-room-select');
      sel.innerHTML = '<option value="">-- choose room --</option>';
      (rooms || []).forEach(room => {
        const opt = document.createElement('option');
        opt.value = room;
        opt.textContent = room;
        sel.appendChild(opt);
      });
    }

    // Voting: include ALL other players (dead or alive)
    function populateVoteDropdown(roster, myPin) {
      const sel = document.getElementById('vote-select');
      sel.innerHTML = '<option value="">-- choose someone --</option>';

      (roster || []).forEach(p => {
        if (String(p.pin) === String(myPin)) return;
        const opt = document.createElement('option');
        opt.value = p.pin;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
    }

    // Kill dropdown – only show when exactly one other living player shares room and canKill=true
    function populateKillDropdown(roomInfo, myPin, canKill) {
      const sel = document.getElementById('kill-target-select');
      const killBtn = document.getElementById('kill-btn');
      if (!sel || !killBtn) return;

      sel.innerHTML = '<option value="">-- no valid victim --</option>';
      sel.disabled = true;
      killBtn.disabled = true;

      if (!roomInfo || !Array.isArray(roomInfo.living)) return;

      const candidates = roomInfo.living.filter(
        p => String(p.pin) !== String(myPin)
      );

      if (canKill && candidates.length === 1) {
        const c = candidates[0];
        const opt = document.createElement('option');
        opt.value = c.pin;
        opt.textContent = c.name;
        sel.appendChild(opt);

        sel.value = String(c.pin);
        sel.disabled = false;
        killBtn.disabled = false;
      }
    }

    function startPlayerPolling(pin) {
      if (playerPollTimer) clearInterval(playerPollTimer);
      playerPollTimer = setInterval(async () => {
        if (!state.pin || String(state.pin) !== String(pin)) return;
        if (document.getElementById('player-view').classList.contains('hidden')) return;

        const { json } = await fetchJSON('/api/state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pin: state.pin })
        });

        if (json && json.ok) {
          const prevStatus = document.getElementById('player-status').textContent;
          applyPlayerState(json);
          document.getElementById('player-status').textContent = prevStatus;
        }
      }, 4000);
    }

    function applyPlayerState(payload) {
  const prevPlayer = state.player;
  const prevAlive = prevPlayer ? prevPlayer.alive : null;

  setRoundLabel(payload.round);

  const p = payload.player;

  // Hide *move / vote / kill* when dead, but keep Ghost Event visible
  const moveSection  = document.getElementById('move-section');
  const voteSection  = document.getElementById('vote-section');
  const killSectionEl = document.getElementById('kill-section');

  if (p.alive) {
    if (moveSection) moveSection.classList.remove('hidden');
    if (voteSection) voteSection.classList.remove('hidden'); // ✅ was moveSection before
    if (killSectionEl) killSectionEl.classList.remove('hidden');
  } else {
    if (moveSection) moveSection.classList.add('hidden');
    if (voteSection) voteSection.classList.add('hidden');
    if (killSectionEl) killSectionEl.classList.add('hidden');
  }

  state.player = p;
  state.pin = p.pin;
  state.revealDots = !!payload.revealDots;

  savePlayerToStorage(state.pin);

  document.getElementById('player-name-label').textContent = p.name;
  document.getElementById('player-role-label').textContent = p.role;
  document.getElementById('player-pin-label').textContent = p.pin;

  // DEAD banner visibility – only on this player's own screen
  const deadBanner = document.getElementById('dead-banner');
  if (deadBanner) {
    if (p.alive) deadBanner.classList.add('hidden');
    else deadBanner.classList.remove('hidden');
  }

  // Ghost event block (only for dead players)
  const ghostBlock = document.getElementById('ghost-event-block');
  if (ghostBlock) {
    if (p.alive) ghostBlock.classList.add('hidden');
    else ghostBlock.classList.remove('hidden');
  }

  // Death popup – only when a Victim flips from alive -> dead
  if (
    prevPlayer &&
    prevAlive === true &&
    p.alive === false &&
    p.role === 'Victim' &&
    popupRounds.death !== payload.round
  ) {
    popupRounds.death = payload.round;
    showGlobalPopup('SHH.. you are now dead.', 'You may not speak, gesture, or hint. Watch in silence.');
  }

  const killSection = document.getElementById('kill-section');
  if (killSection) {
    killSection.style.display = (p.role === 'Killer') ? 'block' : 'none';
  }

  const effects = payload.effects || {};

  // Room Reveal popup – at start of the round when effect is active
  if (effects.roomReveal && popupRounds.roomReveal !== payload.round) {
    popupRounds.roomReveal = payload.round;
    showGlobalPopup(
      'Room Reveal',
      'The restless spirits whisper your positions into the open. All players position revealed this round.'
    );
  }

  // Shove in the Dark popup
  if (effects.shove && popupRounds.shove !== payload.round) {
    popupRounds.shove = payload.round;
    showGlobalPopup(
      'The Shove in the Dark',
      'A violent push from nowhere sends you stumbling into another room. All players randomly relocated.'
    );
  }

  // Killer’s Gaze popup
  if (effects.killerGaze && popupRounds.killerGaze !== payload.round) {
    popupRounds.killerGaze = payload.round;
    showGlobalPopup(
      'Nowhere to hide',
      'No hiding - only the Killer\'s gaze. The killer can see all players positions.'
    );
  }

  // Screams popup
  if (effects.scream && popupRounds.scream !== payload.round) {
    popupRounds.scream = payload.round;
    showGlobalPopup(
      'Screams of the Stolen Lives',
      'Souls cheated of choice scream with rage, overwhelming the living. NO DISCUSSION THIS ROUND. MOVE AND VOTE.'
    );
  }

  populateRoomState(
    payload.roomInfo,
    payload.revealDots,
    payload.roomDots,
    payload.roomClues || [],
    p.clues || []
  );
  populateAllowedRooms(payload.allowedRooms);
  populateVoteDropdown(payload.roster, p.pin);
  populateKillDropdown(payload.roomInfo, p.pin, payload.canKill);

  // Killer move banner – based ONLY on victims moving
  const killerBanner = document.getElementById('killer-move-banner');
  if (killerBanner) {
    killerBanner.classList.remove('waiting', 'ready');
    killerBanner.classList.add('hidden');

    if (p.role === 'Killer') {
      killerBanner.classList.remove('hidden');

      if (payload.allVictimsMoved) {
        killerBanner.textContent = 'All victims have moved.';
        killerBanner.classList.add('ready');
      } else {
        killerBanner.textContent = 'Wait… not all victims have moved yet.';
        killerBanner.classList.add('waiting');
      }
    }
  }

  // ✅ These belong inside applyPlayerState
  show('player');
  startPlayerPolling(p.pin);
}


    async function fetchJSON(url, options) {
      const res = await fetch(url, options);
      const text = await res.text();
      try {
        const json = JSON.parse(text);
        return { status: res.status, json };
      } catch (e) {
        return { status: res.status, json: { ok: false, error: text } };
      }
    }

    /* -------- PLAYER: join / rejoin -------- */

    document.getElementById('join-btn').addEventListener('click', async () => {
      const name = document.getElementById('name-input').value.trim();
      if (!name) {
        setStatus('lobby-status', 'Enter a name first.', true);
        return;
      }

      setStatus('lobby-status', 'Joining game…', false);

      const { json: regJson } = await fetchJSON('/api/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });

      if (!regJson.ok) {
        setStatus('lobby-status', regJson.error || 'Error joining game.', true);
        return;
      }

      const pin = regJson.player.pin;

      const { json: stateJson } = await fetchJSON('/api/state', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin })
      });

      if (!stateJson.ok) {
        setStatus('lobby-status', stateJson.error || 'Error loading state.', true);
        return;
      }

      setStatus(
        'lobby-status',
        'Joined. GM will assign your role and PIN. Keep this screen hidden.',
        false
      );
      applyPlayerState(stateJson);
    });

    document.getElementById('rejoin-btn').addEventListener('click', async () => {
      const pin = document.getElementById('rejoin-pin').value.trim();
      if (!pin) {
        setStatus('lobby-status', 'Enter your PIN to rejoin.', true);
        return;
      }

      setStatus('lobby-status', 'Rejoining…', false);

      const { json: reJson } = await fetchJSON('/api/rejoin', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin })
      });

      if (!reJson.ok) {
        setStatus('lobby-status', reJson.error || 'Error rejoining.', true);
        return;
      }

      const { json: stateJson } = await fetchJSON('/api/state', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin })
      });

      if (!stateJson.ok) {
        setStatus('lobby-status', stateJson.error || 'Error loading state.', true);
        return;
      }

      setStatus('lobby-status', 'Rejoined.', false);
      applyPlayerState(stateJson);
    });

    document.getElementById('leave-game-btn').addEventListener('click', () => {
      clearPlayerStorage();
      state.pin = null;
      state.player = null;

      if (playerPollTimer) {
        clearInterval(playerPollTimer);
        playerPollTimer = null;
      }

      setStatus('player-status', '', false);
      document.getElementById('name-input').value = '';
      document.getElementById('rejoin-pin').value = '';
      show('lobby');
    });

    /* -------- PLAYER: actions -------- */

    document.getElementById('move-btn').addEventListener('click', async () => {
      if (!state.pin) return;

      const room = document.getElementById('move-room-select').value;
      if (!room) {
        setStatus('player-status', 'Choose a room first.', true);
        return;
      }

      setStatus('player-status', 'Sneaking through the house…', false);

      const { json } = await fetchJSON('/api/move', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin, room })
      });

      if (!json.ok) {
        setStatus('player-status', json.error || 'Error moving.', true);
        return;
      }

      const { json: stateJson } = await fetchJSON('/api/state', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin })
      });

      if (!stateJson.ok) {
        setStatus('player-status', stateJson.error || 'Error loading state.', true);
        return;
      }

      setStatus('player-status', json.message || 'Move recorded.', false);
      applyPlayerState(stateJson);
    });

    document.getElementById('kill-btn').addEventListener('click', async () => {
      if (!state.pin) return;

      const sel = document.getElementById('kill-target-select');
      const targetPin = sel ? sel.value : '';
      if (!targetPin) {
        setStatus(
          'player-status',
          'You may only kill when exactly one other living player shares your room, and everyone has moved.',
          true
        );
        return;
      }

      setStatus('player-status', 'You steady your hand…', false);

      const { json } = await fetchJSON('/api/kill', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin, targetPin })
      });

      if (!json.ok) {
        setStatus('player-status', json.error || 'Kill failed.', true);
        return;
      }

      const { json: stateJson } = await fetchJSON('/api/state', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin })
      });

      if (!stateJson.ok) {
        setStatus('player-status', stateJson.error || 'Error loading state.', true);
        return;
      }

      setStatus(
        'player-status',
        json.message || 'Your strike lands. The house will notice soon enough.',
        false
      );
      applyPlayerState(stateJson);
    });

    document.getElementById('vote-btn').addEventListener('click', async () => {
      if (!state.pin) return;

      const targetPin = document.getElementById('vote-select').value;
      if (!targetPin) {
        setStatus('player-status', 'Choose someone to accuse.', true);
        return;
      }

      setStatus('player-status', 'Casting your vote…', false);

      const { json } = await fetchJSON('/api/vote', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin, targetPin })
      });

      if (!json.ok) {
        setStatus('player-status', json.error || 'Error voting.', true);
        return;
      }

      setStatus('player-status', json.message || 'Vote recorded.', false);
    });

    // Ghost vote (dead players)
    document.getElementById('ghost-vote-btn').addEventListener('click', async () => {
      if (!state.pin) return;

      const eventKey = document.getElementById('ghost-event-select').value;
      if (!eventKey) {
        setStatus('player-status', 'Choose an event to vote for as a ghost.', true);
        return;
      }

      setStatus('player-status', 'Your whisper seeps into the house…', false);

      const { json } = await fetchJSON('/api/ghostVote', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pin: state.pin, event: eventKey })
      });

      if (!json.ok) {
        setStatus('player-status', json.error || 'Error casting ghost vote.', true);
        return;
      }

      setStatus('player-status', json.message || 'Ghost vote recorded.', false);
    });

    /* -------- GM helpers -------- */

    function renderGmRoster(players) {
      state.gmPlayers = players || [];
      const tbody = document.querySelector('#gm-roster-table tbody');
      tbody.innerHTML = '';

      (players || []).forEach(p => {
        const tr = document.createElement('tr');

        const tdId = document.createElement('td');
        tdId.textContent = p.id;
        tr.appendChild(tdId);

        const tdName = document.createElement('td');
        tdName.textContent = p.name;
        tr.appendChild(tdName);

        const tdPin = document.createElement('td');
        tdPin.textContent = p.pin;
        tr.appendChild(tdPin);

        const tdRole = document.createElement('td');
        const roleSel = document.createElement('select');
        ['Unknown', 'Victim', 'Killer'].forEach(r => {
          const opt = document.createElement('option');
          opt.value = r;
          opt.textContent = r;
          if (p.role === r) opt.selected = true;
          roleSel.appendChild(opt);
        });
        tdRole.appendChild(roleSel);
        tr.appendChild(tdRole);

        const tdAlive = document.createElement('td');
        const aliveChk = document.createElement('input');
        aliveChk.type = 'checkbox';
        aliveChk.checked = p.alive;
        tdAlive.appendChild(aliveChk);
        tr.appendChild(tdAlive);

        const tdSave = document.createElement('td');
        const btn = document.createElement('button');
        btn.textContent = 'Save';
        btn.style.padding = '4px 10px';
        btn.style.fontSize = '11px';
        btn.addEventListener('click', async () => {
          const { json } = await fetchJSON('/api/gm/updatePlayer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              id: p.id,
              role: roleSel.value,
              alive: aliveChk.checked
            })
          });

          if (!json.ok) {
            setStatus('gm-status', json.error || 'Error saving player.', true);
            return;
          }
          setStatus('gm-status', 'Saved.', false);
        });
        tdSave.appendChild(btn);
        tr.appendChild(tdSave);

        const tdRemove = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'X';
        delBtn.style.padding = '4px 10px';
        delBtn.style.fontSize = '11px';
        delBtn.addEventListener('click', async () => {
          if (!confirm(`Remove ${p.name} (PIN ${p.pin}) from roster?`)) return;

          const { json } = await fetchJSON('/api/gm/removePlayer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: p.id, pin: p.pin })
          });

          if (!json.ok) {
            setStatus('gm-status', json.error || 'Error removing player.', true);
            return;
          }

          setStatus('gm-status', 'Player removed.', false);

          // Refresh via GM summary
          await refreshGmSummaryAndTables();
        });
        tdRemove.appendChild(delBtn);
        tr.appendChild(tdRemove);

        tbody.appendChild(tr);
      });
    }

    async function refreshGmSummaryAndTables() {
      const { json } = await fetchJSON('/api/gm/summary');
      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error loading GM summary.', true);
        return;
      }

      setRoundLabel(json.round);

      // Always refresh roster from summary players
      renderGmRoster(json.players || []);

      const rooms = json.rooms || [];
      const roomNamesBody = document.querySelector('#gm-room-names-table tbody');
      roomNamesBody.innerHTML = '';

      if (!rooms.length) {
        const tr = document.createElement('tr');
        tr.innerHTML = '<td colspan="3">No rooms yet.</td>';
        roomNamesBody.appendChild(tr);
      } else {
        rooms.forEach(r => {
          const names = (r.players || [])
            .map(p => `${p.name} (${p.alive ? 'alive' : 'dead'})`)
            .join(', ') || '—';

          const cluesArr = r.clues || [];
          let cluesHtml = '—';
          if (cluesArr.length) {
            const parts = cluesArr.map(c => {
              if (typeof c === 'string') {
                return `"${c}"`;
              }
              const text = c.text || '';
              if (c.collectedByVictim) {
                return `<span class="clue-collected">"${text}"</span>`;
              }
              return `"${text}"`;
            });
            cluesHtml = parts.join(' / ');
          }

          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${r.room}</td><td>${names}</td><td>${cluesHtml}</td>`;
          roomNamesBody.appendChild(tr);
        });
      }

      // GM live map dots
      document.querySelectorAll('#gm-map .map-room').forEach(div => {
        const dots = div.querySelector('.dots');
        dots.innerHTML = '';
      });

      rooms.forEach(r => {
        const roomDiv = document.querySelector(`#gm-map .map-room[data-room="${r.room}"]`);
        if (!roomDiv) return;
        const dots = roomDiv.querySelector('.dots');

        (r.players || []).forEach(p => {
          const dot = document.createElement('span');
          dot.className = 'map-dot' + (p.alive ? '' : ' dead');
          dot.title = `${p.name} (${p.pin})` + (p.alive ? '' : ' [dead]');
          dots.appendChild(dot);
        });
      });

      const allPlayers = json.players || [];

      const notMovedPins = new Set((json.notMoved || []).map(p => String(p.pin)));
      const notVotedPins = new Set((json.notVoted || []).map(p => String(p.pin)));

      const movesBody = document.querySelector('#gm-moves-table tbody');
      const votesBody = document.querySelector('#gm-votes-table tbody');
      movesBody.innerHTML = '';
      votesBody.innerHTML = '';

      if (!allPlayers.length) {
        const tr1 = document.createElement('tr');
        tr1.innerHTML = '<td colspan="2">No players yet.</td>';
        movesBody.appendChild(tr1);

        const tr2 = document.createElement('tr');
        tr2.innerHTML = '<td colspan="2">No players yet.</td>';
        votesBody.appendChild(tr2);
      } else {
        allPlayers.forEach(p => {
          const pinStr = String(p.pin);

          const moved = !notMovedPins.has(pinStr);
          const moveTr = document.createElement('tr');
          const moveStatus = moved ? 'Moved' : 'Not moved';
          const moveClass = moved ? 'status-good' : 'status-bad';
          moveTr.innerHTML = `<td>${p.name}</td><td class="${moveClass}">${moveStatus}</td>`;
          movesBody.appendChild(moveTr);

          const voted = !notVotedPins.has(pinStr);
          const voteTr = document.createElement('tr');
          const voteStatus = voted ? 'Voted' : 'Not voted';
          const voteClass = voted ? 'status-good' : 'status-bad';
          voteTr.innerHTML = `<td>${p.name}</td><td class="${voteClass}">${voteStatus}</td>`;
          votesBody.appendChild(voteTr);
        });
      }

      // Most Voted For
      const mostBox = document.getElementById('gm-most-voted');
      if (mostBox) {
        const tallies = json.votesByTarget || [];
        if (!tallies.length) {
          mostBox.textContent = 'Most Voted For: —';
        } else {
          const maxCount = Math.max(...tallies.map(t => t.count || 0));
          const top = tallies.filter(t => t.count === maxCount);
          const names = top.map(t => t.name).join(', ');
          mostBox.textContent = `Most Voted For: ${names} – ${maxCount} vote${maxCount === 1 ? '' : 's'}`;
        }
      }

      // Kill attempts for this round
      const killBox = document.getElementById('gm-kill-attempts');
      if (killBox) {
        const attempts = json.killAttempts || [];
        if (!attempts.length) {
          killBox.textContent = 'No kill attempts this round yet.';
        } else {
          const list = document.createElement('ul');
          attempts.forEach(k => {
            const li = document.createElement('li');
            const resolvedText = k.resolved ? '' : ' (pending)';
            const victimName = k.victimName || `PIN ${k.victimPin}`;
            li.textContent = `Killer attempted kill on ${victimName} in ${k.room}${resolvedText}`;
            list.appendChild(li);
          });
          killBox.innerHTML = '';
          killBox.appendChild(list);
        }
      }

      // Ghost votes table
      const ghostBody = document.querySelector('#gm-ghost-votes-table tbody');
      if (ghostBody) {
        ghostBody.innerHTML = '';
        const ghosts = json.ghostVotes || [];
        if (!ghosts.length) {
          const tr = document.createElement('tr');
          tr.innerHTML = '<td colspan="3">No dead players yet.</td>';
          ghostBody.appendChild(tr);
        } else {
          ghosts.forEach(g => {
            const tr = document.createElement('tr');
            const voted = !!g.event;
            const label = g.eventLabel || (g.event || '—');
            tr.innerHTML = `<td>${g.name}</td><td class="${voted ? 'status-good' : 'status-bad'}">${voted ? 'Voted' : 'No vote'}</td><td>${voted ? label : '—'}</td>`;
            ghostBody.appendChild(tr);
          });
        }
      }

      // Ghost majority display
      const ghostMajor = document.getElementById('gm-ghost-majority');
      if (ghostMajor) {
        const gmj = json.ghostMajority;
        if (!gmj) {
          ghostMajor.textContent = 'Ghost Majority Vote: —';
        } else {
          ghostMajor.textContent =
            `Ghost Majority Vote: ${gmj.label} (${gmj.count} vote${gmj.count === 1 ? '' : 's'})`;
        }
      }

            // 🔹 Sync Killer's Advantage UI from server
      const killerAdv = json.killersAdvantage || {};
      const killerInput = document.getElementById('gm-killers-adv-interval');
      if (killerInput && Number.isFinite(killerAdv.interval)) {
        killerInput.value = killerAdv.interval;
      }



      const ghostIntervalInput = document.getElementById('gm-ghost-interval-input');
      if (ghostIntervalInput && json.ghostEventInterval) {
        ghostIntervalInput.value = json.ghostEventInterval;
      }
    }

    function startGmPolling() {
      if (gmPollTimer) clearInterval(gmPollTimer);
      gmPollTimer = setInterval(async () => {
        if (document.getElementById('gm-view').classList.contains('hidden')) return;
        await refreshGmSummaryAndTables();
      }, 4000);
    }

    /* -------- GM Timer helpers -------- */

    function formatSeconds(sec) {
      const s = Math.max(0, Math.floor(sec));
      const m = Math.floor(s / 60);
      const ss = s % 60;
      return `${String(m).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
    }

    function updateGmTimerDisplay() {
      const display = document.getElementById('gm-timer-display');
      if (!display) return;
      display.textContent = formatSeconds(gmTimerRemaining);
    }

    function startGmTimer() {
      const input = document.getElementById('gm-timer-input');
      const value = parseInt(input.value, 10);
      if (isNaN(value) || value <= 0) {
        setStatus('gm-status', 'Enter a positive number of seconds for the timer.', true);
        return;
      }
      gmTimerRemaining = value;
      updateGmTimerDisplay();

      if (gmTimerInterval) clearInterval(gmTimerInterval);
      gmTimerInterval = setInterval(() => {
        gmTimerRemaining -= 1;
        updateGmTimerDisplay();
        if (gmTimerRemaining <= 0) {
          gmTimerRemaining = 0;
          updateGmTimerDisplay();
          clearInterval(gmTimerInterval);
          gmTimerInterval = null;
        }
      }, 1000);
    }

    function stopGmTimer() {
      if (gmTimerInterval) {
        clearInterval(gmTimerInterval);
        gmTimerInterval = null;
      }
    }

    function resetGmTimer() {
      stopGmTimer();
      const input = document.getElementById('gm-timer-input');
      gmTimerRemaining = parseInt(input.value, 10) || 120;
      updateGmTimerDisplay();
    }

    /* -------- GM: unlock & buttons -------- */

    document.getElementById('gm-unlock-btn').addEventListener('click', async () => {
      const gmPin = document.getElementById('gm-pin').value.trim();
      if (!gmPin) {
        setStatus('gm-unlock-status', 'Enter GM PIN.', true);
        return;
      }

      const { json } = await fetchJSON('/api/gm/unlock', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ gmPin })
      });

      if (!json.ok) {
        setStatus('gm-unlock-status', json.error || 'GM unlock failed.', true);
        return;
      }

      state.gmPin = gmPin;
      setStatus('gm-unlock-status', 'GM panel unlocked on this device.', false);
      setRoundLabel(json.round);
      renderGmRoster(json.players);
      await refreshGmSummaryAndTables();
      show('gm');
      updateGmTimerDisplay();
      startGmPolling();
    });

    document.getElementById('gm-randomize-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/randomizeRoles', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error randomizing roles.', true);
        return;
      }

      setStatus('gm-status', 'Roles assigned.', false);
      renderGmRoster(json.players);
      await refreshGmSummaryAndTables();
    });

    document.getElementById('gm-next-round-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/nextRound', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error advancing round.', true);
        return;
      }

      setRoundLabel(json.round);
      setStatus('gm-status', 'Round advanced.', false);
      await refreshGmSummaryAndTables();
    });

    document.getElementById('gm-new-game-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/newGame', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error resetting game.', true);
        return;
      }

      setRoundLabel(json.round);
      renderGmRoster([]);
      document.getElementById('gm-room-names-table').querySelector('tbody').innerHTML = '';
      document.getElementById('gm-moves-table').querySelector('tbody').innerHTML = '';
      document.getElementById('gm-votes-table').querySelector('tbody').innerHTML = '';
      document.querySelectorAll('#gm-map .map-room .dots').forEach(d => d.innerHTML = '');
      const mostBox = document.getElementById('gm-most-voted');
      if (mostBox) mostBox.textContent = 'Most Voted For: —';

      const killBox = document.getElementById('gm-kill-attempts');
      if (killBox) killBox.textContent = 'No kill attempts this round yet.';

      const ghostBody = document.querySelector('#gm-ghost-votes-table tbody');
      if (ghostBody) ghostBody.innerHTML = '<tr><td colspan="3">No dead players yet.</td></tr>';
      const ghostMajor = document.getElementById('gm-ghost-majority');
      if (ghostMajor) ghostMajor.textContent = 'Ghost Majority Vote: —';

      setStatus(
        'gm-status',
        'Game reset. Tell everyone to tap "Leave Game / Join New Run" and re-enter their names.',
        false
      );
    });

    // Toggle whether Killer can see clues in rooms
    document.getElementById('gm-killer-clues-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/toggleKillerClues', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error toggling killer clues.', true);
        return;
      }

      setStatus(
        'gm-status',
        json.killerSeesClues
          ? 'Killers can now see clue fragments in their current room.'
          : 'Killers can no longer see clue fragments in their current room.',
        false
      );
    });

    // Room Reveal (next round)
    document.getElementById('gm-reveal-dots-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/toggleRevealDots', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error toggling Room Reveal.', true);
        return;
      }

      setStatus(
        'gm-status',
        json.revealDotsNextRound
          ? 'Room Reveal armed for the next round.'
          : 'Room Reveal cleared for the next round.',
        false
      );
    });

    // Shove in the Dark (next round)
    document.getElementById('gm-shove-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/toggleShove', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error toggling Shove in the Dark.', true);
        return;
      }

      setStatus(
        'gm-status',
        json.shoveNextRound
          ? '"The Shove in the Dark" armed for the next round.'
          : '"The Shove in the Dark" cleared for the next round.',
        false
      );
    });

    // Killer's Gaze (next round)
    document.getElementById('gm-killer-gaze-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/toggleKillerGaze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error toggling Killer\'s Gaze.', true);
        return;
      }

      setStatus(
        'gm-status',
        json.killerVisionNextRound
          ? '"Killer\'s Gaze" armed for the next round.'
          : '"Killer\'s Gaze" cleared for the next round.',
        false
      );
    });

    // Screams (next round)
    document.getElementById('gm-scream-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/toggleScream', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error toggling Screams.', true);
        return;
      }

      setStatus(
        'gm-status',
        json.screamNextRound
          ? '"Screams" armed for the next round.'
          : '"Screams" cleared for the next round.',
        false
      );
    });

    // Scatter players now
    document.getElementById('gm-scatter-now-btn').addEventListener('click', async () => {
      const { json } = await fetchJSON('/api/gm/scatterPlayers', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error scattering players.', true);
        return;
      }

      setStatus(
        'gm-status',
        `Scattered ${json.scattered} player(s) evenly and randomly across rooms.`,
        false
      );
      await refreshGmSummaryAndTables();
    });

    // 🔴 Scatter Clues button
    document.getElementById('gm-generate-clues-btn').addEventListener('click', async () => {
      const input = document.getElementById('gm-secret-sentence');
      const sentence = input.value.trim();

      if (!sentence) {
        setStatus('gm-clues-status', 'Enter a secret sentence first.', true);
        return;
      }

      setStatus('gm-clues-status', 'Scattering clues across the house…', false);

      const { json } = await fetchJSON('/api/gm/generateClues', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sentence: sentence })
      });

      if (!json.ok) {
        setStatus('gm-clues-status', json.error || 'Error generating clues.', true);
        return;
      }

      // If server echoes the sentence back, keep them in sync
      if (json.secretSentence) {
        input.value = json.secretSentence;
      }

      setStatus(
        'gm-clues-status',
        json.message || 'Clues generated and scattered into the rooms.',
        false
      );

      await refreshGmSummaryAndTables();
    });

    // GM timer buttons
    document.getElementById('gm-timer-start-btn').addEventListener('click', () => {
      startGmTimer();
    });
    document.getElementById('gm-timer-stop-btn').addEventListener('click', () => {
      stopGmTimer();
    });
    document.getElementById('gm-timer-reset-btn').addEventListener('click', () => {
      resetGmTimer();
    });

    // Killer's Advantage config
    document.getElementById('gm-killers-adv-toggle-btn').addEventListener('click', async () => {
      const input = document.getElementById('gm-killers-adv-interval');
      let interval = parseInt(input.value, 10);
      if (isNaN(interval) || interval < 1) {
        interval = 3;
      }

      const { json } = await fetchJSON('/api/gm/setKillersAdvantage', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ interval, toggle: true })
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error updating Killer’s Advantage.', true);
        return;
      }

      input.value = json.interval;
      setStatus(
        'gm-status',
        `Killer’s Advantage ${json.enabled ? 'ENABLED' : 'DISABLED'} (every ${json.interval} rounds).`,
        false
      );
    });

    // Ghost event interval
    document.getElementById('gm-ghost-interval-btn').addEventListener('click', async () => {
      const input = document.getElementById('gm-ghost-interval-input');
      let interval = parseInt(input.value, 10);
      if (isNaN(interval) || interval < 1) {
        interval = 5;
      }

      const { json } = await fetchJSON('/api/gm/setGhostEventInterval', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ interval })
      });

      if (!json.ok) {
        setStatus('gm-status', json.error || 'Error setting ghost event interval.', true);
        return;
      }

      input.value = json.interval;
      setStatus(
        'gm-status',
        `Ghost event interval set to every ${json.interval} rounds.`,
        false
      );
    });

    // Auto-rejoin if stored PIN
    (async function init() {
      const savedPin = loadPlayerFromStorage();
      if (savedPin) {
        const { json } = await fetchJSON('/api/state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pin: savedPin })
        });

        if (json && json.ok) {
          applyPlayerState(json);
          return;
        } else {
          clearPlayerStorage();
        }
      }
      show('lobby');
    })();
  </script>
</body>
</html>
